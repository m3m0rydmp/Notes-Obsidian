Also known as directory traversal. These vulnerabilities enable an attacker to read arbitrary files on the server that is running an application. This might include:
* Application code and data
* Credentials for back-end systems
* Sensitive operating system files
In some cases, an attacker might be able to write to arbitrary files on the server, allowing them to modify the application data or behaviour, and ultimately take full control of the server.

## Reading Arbitrary Files via Path Traversal
A shopping application that displays images of items for sale, loads an image using the following HTML:
```html
<img src="/loadImage?filename=218.png">
```
The `loadImage` URL takes a `filename` parameter and returns the contents of the specified file. The image files are stored on disk in the location `/var/www/images/`. To return an image, the application appends the requested filename to this base directory and uses a filesystem API to read the contents of the file. In other words, the application reads from the following file path:
```text
/vat/www/images/218.png
```
This application implements no defences against path traversal attacks. As a result, an attacker can request the following URL to retrieve the `/etc/passwd` file from the server's filesystem:
```
https://insecure-website.com/loadImage?filename=../../../etc/passwd
```
This causes the application to read from the following file path:
```
/var/www/images/../../../etc/passwd
```
The sequence `../` is valid within a file path, and means to step up one level in the directory structure. The three consecutive `../` sequence step up from `/var/www/images/` to the filesystem root, and so the file that is actually read is: `/etc/passwd`
On Unix-based operating systems, this is a standard file containing details of the users that are registered on the server, but an attacker could retrieve other arbitrary files using the same technique.
On Windows, both `../` and `..\` are valid directory traversal sequences. The following is an example of an equivalent attack against a Windows-based server:
```text
https://example.com/loadImage?filename=..\..\..\windows\win.ini
```

## Common Obstacles to Exploiting Path Traversal
If an application strips or blocks directory traversal sequences from the user-supplied filename, it might be possible to bypass the defence using a variety of techniques.

You might be able to use an absolute path from the filesystem root, such as `filename=/etc/passwd`, to directly reference a file without using any traversal sequences.

You can also use nested traversal sequences, such as `....//` or `....\\`. These revert to simple traversal sequences when the **inner sequence is stripped**

In some contexts, such as in a URL path or the `filename` parameter of a `multipart/form-data` request, web servers may strip any directory traversal sequences before passing your input to the application. You can sometimes bypass this kind of sanitization by URL encoding, or even double URL encoding, the `../` characters. This results in `%2e%2e%2f` and `%252e%252e%252f` respectively. Various non-standard encodings, such as `..%c0%af` of `..%ef%bc%8f`, may also work.

For Burp Suite Professional users, Burp Intruder provides the predefined payload list Fuzzing - path traversal. This contains some encoded path traversal sequences that you can try.

An application may require the user-supplied filename to start with the expected base folder, such as `/var/www/images`. In this case, it might be possible to include the required base folder followed by suitable traversal sequences. For example: `filename=/var/www/images/../../../etc/passwd`

An application may require the user-supplied filename to end with an expected file extension, such as `.png`. In this case, it might be possible to use a null byte to effectively terminate the file path before the required extension. For example: `filename=../../../etc/passwd%00.png`

On another note that I've learned. The more `../` that you put in the payload, it cancels the directory before the `../`. For example: `/var/www/html/includes/../etc/passwd` becomes `/var/www/html/etc/passwd`, just giving different POV on how LFI works helps us understand in attacking a web app that is vulnerable to LFI.


## Path Traversal, Simple Case
[LAB: Path traversal, simple case](https://portswigger.net/web-security/file-path-traversal/lab-simple)
A simple case payload of path traversal would be `../../../etc/passwd`. If we browse the lab and click on any image. The web server fetch an image before displaying the `productId` of the image clicked. Using **BurpSuite** we can intercept the request that fetches the `filename=` of the image. This won't appear in HTTP History of BurpSuite so you need to turn on the interceptor before sending the request and play with it in **Repeater**.

Once you found the `/image?filename=image1.png` parameter. Remove the `image1.png` then replace it with the LFI payload `../../../../etc/passwd`. 

## File Path Traversal, Traversal Sequences Blocked with Absolute Path Bypass
[LAB: File path traversal, traversal sequences blocked with absolute path bypass](https://portswigger.net/web-security/file-path-traversal/lab-absolute-path-bypass)
Since simple case payload like `../../etc/passwd` won't work anymore. Bypass it with `/etc/passwd` which is directly specifying where the file is, as the name suggests **Absolute Path**, you can call files from the `/`. The vulnerable parameter is the same as the one above which is `filename=`

## File Path Traversal, Traversal Sequences Stripped non-recursively
[LAB: File path traversal, traversal sequences stripped non-recursively](https://portswigger.net/web-security/file-path-traversal/lab-sequences-stripped-non-recursively)
Since a simple case payload `../` is stripped. You just need to double the payload such as `....//etc/passwd` notice that when traversing to the `passwd` file from `etc` you only need 1 `/`. The web application will only strip `../` so when doubling it, it reverts back to the simple case payload since only this `../` is the only one that is stripped. The vulnerable parameter is the same as before which is the `filename=`

## File Path Traversal, Traversal Sequences Stripped with Superfluous URL-Decode
[LAB: File path traversal, traversal sequences stripped with superfluous URL-decode](https://portswigger.net/web-security/file-path-traversal/lab-superfluous-url-decode)
Superfluous refers to a security vulnerability where an application decodes user input multiple times or unnecessarily, allowing attackers to bypass security filters. By encoding malicious input like `../` twice, the initial security check fails to detect the payload, which is then decoded by the application, resulting in malicious code execution. Basically, you **double URL encode** the payload.

A simple case payload of `../` turns into `..%2F` then encode it again it turns `..%252F`. So the final payload would be `..%252F..%252F..%252Fetc%252Fpasswd`. The vulnerable parameter is still the same which is the `filename=`

## File Path Traversal, Validation of Start of Path
[LAB: File path traversal, validation of start of path](https://portswigger.net/web-security/file-path-traversal/lab-validate-start-of-path)
This lab calls the file from the start of the path, basically the **root** or `/`. If you intercept the request, the parameter is written as `?filename=/var/www/images/21.png`. A simple case payload would work on this, but we don't need to remove the `/var/www/images` since the `../` will climb up the directory by its own. Where putting a `../` cancels out one directory before it. For example: `/var/www/images/../21.png` becomes `/var/www/21.png` when decoded by the web application. So we know that there are 3 directories above before we reach `/etc/passwd` so the final payload is `/var/www/images/../../../etc/passwd`.

## File Path Traversal, Validation of File Extension with Null Byte Bypass
[LAB: File path traversal, validation of file extension with null byte bypass](https://portswigger.net/web-security/file-path-traversal/lab-validate-file-extension-null-byte-bypass)
This lab only reads the path if it ends with the file type like `.jpg`,`.png` or something similar.  Typical vulnerable backend code of it would look like:
```php
<?php
// Vulnerable PHP code (old versions)
$file = $_GET['page'];
include("pages/" . $file . ".php");
?>
```
So by using a simple case payload, we also add a null byte which is `%00`. The null byte is an end of string marker in `C/C++` in URLs it's `%00`. In a C code, anything after `\0` is ignored, an example would be:
```c
// C string in memory
char str[] = "hello";

// Actually stored as:
['h']['e']['l']['l']['o']['\0']
                         â†‘
                    String ends here
```
So the web application looks for the `.jpg` file type. But with a succession of a null byte, the payload `../../etc/passwd%00.jpg` will be interpreted by the web application as `../../etc/passwd` since the `.jpg` is ignored already.

The final payload would be `../../../../etc/passwd%00.jpg` where the vulnerable parameter is the same as before which is the `filename=`

